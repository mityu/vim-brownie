let s:scope = themis#helper('scope')
let s:funcs = s:scope.funcs('autoload/brownie.vim')
let s:vars = s:funcs.script_variables()
call themis#func_alias(s:funcs)
call themis#func_alias(s:vars.extractor)
call themis#func_alias(s:vars.viewer)
call themis#func_alias(s:vars.options_shelter)
call themis#helper('command').with(themis#helper('assert'))

Describe [brownie.vim]
  Before all
    function! Call(script)
      let [func, args] = split(
            \ substitute(a:script, '\s', '', 'g'),
            \ '^\_[^(]\{-}\zs\ze(')
      return call(s:funcs[func], eval('[' . args[1 : -2] . ']'))
    endfunction
    command! -nargs=+ Call call Call(<q-args>)

    function! WholeBufline()
      return getline(1, '$')
    endfunction

    let g:brownie_template_dirs = [s:vars.plugin_root . '/test/template']
  End

  After all
    delfunction Call
    delcommand Call
  End

  Describe s:let_default()
    After each
      unlet g:test
    End

    It doesn't allow to assign twice.
      Call let_default('g:test', 0)
      Assert Equals(g:test, 0)
      Call let_default('g:test', 1)
      Assert Equals(g:test, 0)
    End

    It doesn't assign when the variable is already declared.
      let g:test = 0
      Call let_default('g:test', 1)
      Assert Equals(g:test, 0)
    End

  End

  Describe s:use_softtab()
    After all
      setlocal noexpandtab
    End

    It returns 1 when expandtab is enabled.
      setlocal expandtab
      let v = s:funcs.use_softtab()
      Assert Equals(v, 1)
    End

    It returns 0 when expandtab is disabled.
      setlocal noexpandtab
      let v = s:funcs.use_softtab()
      Assert Equals(v, 0)
    End
  End

  Describe s:str_divide_pos()
    It separates string with provided the position.
      let s = 'hogefuga'
      let r = s:funcs.str_divide_pos(s, strlen('hoge'))
      Assert Equals(r, ['hoge', 'fuga'])
    End

    It can separate string even if 0 is provided as the position.
      let s = 'hoge'
      let r = s:funcs.str_divide_pos(s, 0)
      Assert Equals(r, ['', s])
    End

    It can separate string even if length of string is provided as the position.
      let s = 'hoge'
      let r = s:funcs.str_divide_pos(s, strlen(s))
      Assert Equals(r, [s, ''])
    End
  End

  Describe brownie#is_buffer_empty()
    It returns true when buffer is empty.
      silent % delete _
      Assert Equals(brownie#is_buffer_empty(), 1)
    End

    It returns false when buffer is not empty.
      call setline(1, 'hoge')
      Assert Equals(brownie#is_buffer_empty(), 0)
    End

    Context from another buffer
      Before all
      End
      After all
        % bwipeout!
      End
      It returns true when buffer is empty.
        silent % delete _
        let bufnr = bufnr('%')
        new
        call setline(1, 'hoge')
        Assert Equals(brownie#is_buffer_empty(bufnr), 1)
      End

      It returns false when buffer is not empty.
        call setline(1, 'hoge')
        let bufnr = bufnr('%')
        new
        call setline(1, 'fuga')
        Assert Equals(brownie#is_buffer_empty(bufnr), 0)
      End
    End
  End

  Describe brownie#list()
    Before all
      function List(filetype, kind) abort
        return sort(brownie#list(a:kind))
      endfunction
    End
    After all
      delfunction List
    End
    It lists templates.
      Assert Equals(brownie#list('list', 'template'),
            \ sort(['always', 'template', 'always-always', 'always-template']))
    End
    It lists snippets.
      Assert Equals(brownie#list('list', 'snippet'),
            \ sort(['always', 'snippet', 'always-always', 'always-snippet']))
    End
    It can list templates even when filetype is empty.
      Assert Equals(brownie#list('', 'template'),
            \ sort(['always-always', 'always-template']))
    End
    It can list snippets even when filetype is empty.
      Assert Equals(brownie#list('', 'snippet'),
            \ sort(['always-always', 'always-snippet']))
    End
  End

  Describe brownie#extract()
    After all
      delfunction Extract
    End

    Before each
      silent % delete _
    End

    Context template
      Before all
        function! Extract(name) abort
          return brownie#extract('extract', 'template', a:name)
        endfunction
      End

      It extracts a template - oneline
        call Extract('oneline')
        Assert Equals(WholeBufline(), ['template'])
      End

      It extracts a template - multiline
        call Extract('multiline')
        Assert Equals(WholeBufline(), ['template', 'template'])
      End

      It extracts a template - replace
        call Extract('replace')
        Assert Equals(WholeBufline(), ['replaced'])
      End

      It extracts a template - cursor1
        call Extract('cursor1')
        Assert Equals(line('.'), 2)
        Assert Equals(WholeBufline(), ['template', '', 'template'])
      End

      It extracts a template - cursor2
        call Extract('cursor2')
        Assert Equals(getline('.'), 'cursor_line')
      End

      It extracts a template - cursor3
        call Extract('cursor3')
        Assert Equals(getline('.'), 'cursor_line')
      End

      It extracts a template - cursor4
        call Extract('cursor4')
        Assert Equals(getline('.'), 'cursor_line')
      End

      It extracts a template - command
        let g:test_msg = ''
        call Extract('command')
        Assert Equals(g:test_msg, 'executed')
      End

      It extracts a template with softtab - indent
        setlocal expandtab shiftwidth=2
        call Extract('indent')
        Assert Equals(WholeBufline(), ['  indent'])
        setlocal noexpandtab
      End
    End

    Context snippet
      Context in normal-mode
        Before all
          function! Extract(name) abort
            return brownie#extract('extract', 'snippet', a:name)
          endfunction
        End

        It extracts a snippet - oneline
          call Extract('oneline')
          Assert Equals(WholeBufline(), ['snippet'])
        End

        It extracts a snippet - multiline
          call Extract('multiline')
          Assert Equals(WholeBufline(), ['snippet', 'snippet'])
        End

        It extracts a snippet with indentations - multiline
          call setline(1, "\t")
          normal! $
          call Extract('multiline')
          Assert Equals(WholeBufline(), ["\tsnippet", "\tsnippet"])
        End

        It extracts a snippet - command
          let g:test_msg = ''
          call Extract('command')
          Assert Equals(g:test_msg, 'executed')
        End

        It extracts a snippet - cursor1
          call Extract('cursor1')
          Assert Equals(line('.'), 2)
          Assert Equals(WholeBufline(), ['snippet', '', 'snippet'])
        End

        It extracts a snippet - cursor2
          call Extract('cursor2')
          Assert Equals(WholeBufline(), ['snippet', 'cursor_line', 'snippet'])
        End

        It extracts a snippet - cursor3
          call Extract('cursor3')
          Assert Equals(WholeBufline(), ['snippet', 'cursor_line', 'snippet'])
        End

        It extracts a snippet - cursor4
          call Extract('cursor4')
          Assert Equals(WholeBufline(), ['snippet', 'cursor_line', 'snippet'])
        End

        It extracts a snippet - replace
          call Extract('replace')
          Assert Equals(getline('.'), 'snippet')
        End
      End

      Context in insert-mode
        Before all
          function! Extract(name) abort
            startinsert!
            return brownie#extract('extract', 'snippet', a:name)
            stopinsert
          endfunction
        End

        It extracts a snippet with indentations - multiline
          call setline(1, "\t")
          call Extract('multiline')
          Assert Equals(WholeBufline(), ["\tsnippet", "\tsnippet"])
        End

        It extracts a snippet - cursor1
          call Extract('cursor1')
          Assert Equals(line('.'), 2)
          Assert Equals(WholeBufline(), ['snippet', '', 'snippet'])
        End

        It extracts a snippet - cursor2
          call Extract('cursor2')
          Assert Equals(WholeBufline(), ['snippet', 'cursor_line', 'snippet'])
        End

        It extracts a snippet - cursor3
          call Extract('cursor3')
          Assert Equals(WholeBufline(), ['snippet', 'cursor_line', 'snippet'])
        End

        It extracts a snippet - cursor4
          call Extract('cursor4')
          Assert Equals(WholeBufline(), ['snippet', 'cursor_line', 'snippet'])
        End

        It extracts a snippet - replace
          call Extract('replace')
          Assert Equals(getline('.'), 'snippet')
        End
      End
    End
  End
End
